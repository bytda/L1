package main

import (
	"fmt"
	"sort"
)

/*
Задание:
Реализовать пересечение двух неупорядоченных множеств.
*/

func main() {
	a := []int{12, 43, 11, 7, 4, 9, 54, 1}          //объвляем неупорядоченное множество
	b := []int{0, 31, 5, 44, 11, 98, 4, 42, 88, 93} //объвляем неупорядоченное множество
	var c []int                                     //объвляем слайс для пересенных (общих) значений
	//c = HashMap(a, b)                               //способ с помощью мапы (хеш-таблицы)

	c = SortComp(a, b) //способ с помощью сортировки и парарельным обходом
	fmt.Println(c)     //выводим общие значения двух множеств
}

func HashMap(a, b []int) []int { //объвляем функцию
	m := make(map[int]struct{}) //создаем мапу для записи значений
	var c []int                 //создаем слайс для результата
	for _, i := range a {       //перебираем первое множество
		m[i] = struct{}{} //значения множества записываем как ключи, а в значениях мапа просто пустые структуры
	}
	for _, i := range b { //перебираем второже множество
		if _, ok := m[i]; ok { //подставляем значения второго множества в качестве ключа мапы, если есть совпадение ок=true
			c = append(c, i) //тогда значение которое совпало записываем в слайс результатов
		}
	}
	return c //возращаем итоговый слайс
}

func SortComp(a, b []int) []int { //объвляем функцию
	sort.Ints(a) //сортируем слайсы по возрастанию
	sort.Ints(b) //сортируем слайсы по возрастанию
	var c []int  //создаем слайс для пересечений
	var i, j int //переменные для индексов
	for {
		if i < len(a) && j < len(b) { //если выходим за пределы множества то пересечений больше нет
			if a[i] > b[j] { // сдвиг на 1 шаг во втором множестве если элемент первого больше элемента второго
				j++      //повышаем индекс
				continue //отправляем в начало цикла
			}
			if a[i] < b[j] { // сдвиг на 1 шаг в первом множестве если элемент второго больше элемента первого
				i++      //повышаем индекс
				continue //отправляем в начало цикла
			}
			c = append(c, a[i]) // если они равны, то добавляем значение в возвращаемый слайс и сдвигаемся в обоих множествах
			i++                 //повышаем оба индекса
			j++                 //повышаем оба индекса
			continue            //отправляем в начало цикла
		}
		break //прерываем цикл
	}

	return c //возращаем результат

}
